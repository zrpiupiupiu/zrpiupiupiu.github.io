<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>matlab图像处理</title>
    <link href="/2023/05/04/matlab%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <url>/2023/05/04/matlab%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">彩色图像：每个像素由R、G、B三个分量表示，每个通道取值范围<span class="hljs-number">0</span>~<span class="hljs-number">255</span>。数据类型一般为<span class="hljs-number">8</span>位无符号整形。<br><br>灰度图像：每个像素只有一个采样颜色的图像，这类图像通常显示为从最暗黑色到最亮的白色的灰度。<br><br>二值图像（黑白图像）：每个像素点只有两种可能，<span class="hljs-number">0</span>和<span class="hljs-number">1.0</span>代表黑色，<span class="hljs-number">1</span>代表白色。数据类型通常为<span class="hljs-number">1</span>个二进制位。<br><br>索引图像：类似于查字典，为了解决彩色图像消耗空间大的问题，一般应用于色彩构成比较简单的场景。<br><br></code></pre></td></tr></table></figure><ul><li>彩色图像（color image）：<strong>每个像素通常是由红（R）、绿（G）、蓝（B）三个分量来表示的，分量介于（0，255）</strong>。RGB图像与索引图像一样都可以用来表示彩色图像。与索引图像一样，它分别用红（R）、绿（G）、蓝（B）三原色的组合来表示每个像素的颜色。但与索引图像不同的是，RGB图像每一个像素的颜色值（由RGB三原色表示）直接存放在图像矩阵中，由于每一像素的颜色需由R、G、B三个分量来表示，M、N分别表示图像的行列数，三个M x N的二维矩阵分别表示各个像素的R、G、B三个颜色分量。RGB图像的数据类型一般为8位无符号整形，通常用于表示和存放真彩色图像，当然也可以存放灰度图像。</li><li>灰度图像（gray image）是<strong>每个像素只有一个采样颜色的图像，这类图像通常显示为从最暗黑色到最亮的白色的灰度</strong>，尽管理论上这个采样可以任何颜色的不同深浅，甚至可以是不同亮度上的不同颜色。灰度图像与黑白图像不同，在计算机图像领域中黑白图像只有黑色与白色两种颜色；但是，灰度图像在黑色与白色之间还有许多级的颜色深度。灰度图像经常是在单个电磁波频谱如可见光内测量每个像素的亮度得到的，用于显示的灰度图像通常用每个采样像素8位的非线性尺度来保存，这样可以有256级灰度（如果用16位，则有65536级）。</li><li>二值图像（binary image），即<strong>一幅二值图像的二维矩阵仅由0、1两个值构成，“0”代表黑色，“1”代白色</strong>。由于每一像素（矩阵中每一元素）取值仅有0、1两种可能，所以计算机中二值图像的数据类型通常为1个二进制位。二值图像通常用于文字、线条图的扫描识别（OCR）和掩膜图像的存储。</li><li>索引图像，即它的<strong>文件结构比较复杂，除了存放图像的二维矩阵外，还包括一个称之为颜色索引矩阵MAP的二维数组</strong>。MAP的大小由存放图像的矩阵元素值域决定，如矩阵元素值域为[0，255]，则MAP矩阵的大小为256Ⅹ3，用MAP=[RGB]表示。MAP中每一行的三个元素分别指定该行对应颜色的红、绿、蓝单色值，MAP中每一行对应图像矩阵像素的一个灰度值，如某一像素的灰度值为64，则该像素就与MAP中的第64行建立了映射关系，该像素在屏幕上的实际颜色由第64行的[RGB]组合决定。也就是说，图像在屏幕上显示时，每一像素的颜色由存放在矩阵中该像素的灰度值作为索引通过检索颜色索引矩阵MAP得到。索引图像的数据类型一般为8位无符号整形（int8），相应索引矩阵MAP的大小为256Ⅹ3，因此一般索引图像只能同时显示256种颜色，但通过改变索引矩阵，颜色的类型可以调整。索引图像的数据类型也可采用双精度浮点型（double）。索引图像一般用于存放色彩要求比较简单的图像，如Windows中色彩构成比较简单的壁纸多采用索引图像存放，如果图像的色彩比较复杂，就要用到RGB真彩色图像。</li></ul><p>判断是什么图片:</p><p>右击图片属性，摘要，点击详细属性，里面有位深度一项。如果是RGB图，位深度是24；如果是灰度和索引图，位深度是8；灰度是白灰黑表示的图，索引图有可能是彩色的，但也是8位深。</p><hr><h2 id="rgb图像转为灰度图像">rgb图像转为灰度图像</h2><p>matlab中图像处理的一些简单函数</p><ol><li><code>imread()</code></li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">imread()用于读入各种图像文件<br>语法格式:<br>[X，MAP]=imread(‘filename’,‘fmt’)<br>X，MAP分别为读出的图像数据和颜色表数据，fmt为图像的格式，filename为读取的图像文件（可以加上文件的路径）<br></code></pre></td></tr></table></figure><ol start="2"><li><code>imwrite()</code></li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">imwrite() 用于输出图像<br>语法格式:<br>imwrite(X,map,filename,fmt)<br>按照fmt指定的格式将图像数据矩阵X和调色板map写入文件filename<br></code></pre></td></tr></table></figure><ol start="3"><li><p><code>imfinfo()</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">imfinfo用于读取图像文件的有关信息<br>语法格式:<br>imfinfo(filename,fmt)<br>imfinfo函数返回一个结构info，它反映了该图像的各方面信息，其主要数据包括：文件名（路径）、文件格式、文件格式版本号、文件的修改时间、文件的大小、文件的长度、文件的宽度、每个像素的位数、图像的类型等。<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202305041903362.png" alt="image-20230504190300316"></p></li><li><p><code>imshow()</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">imshow函数是最常用的显示各种图像的函数<br>语法如下:<br>imshow(X,map)<br>X是图像数据矩阵，map是其对应的颜色矩阵，若进行图像处理后不知道图像数据的值域可以用[]代替map<br></code></pre></td></tr></table></figure><ul><li><p>二进制（二值）图像显示方法，在MATLAB中一幅二值图像是uint8或双精度的，该矩阵仅包含0和1。如果希望工具箱中的函数能将图像理解为二进制的，那么所有数据都要是逻辑数据，必须对其进行设置（将所有数据标志均设置on）.可以对数据利用“~”取反操作实现图像逆转即黑白反色。</p></li><li><p>灰度图像的显示方法，正常情况下无需指定灰度图像的调色板格式。可以是使用imshow函数指定要显示灰度级数目，格式<code> imshow(I,n)</code>,n为指定的灰度级数目。用户也可以指定数据的范围，格式imshow(I,[low high])其中low 和high参数分别为数据数组的最小值和最大值。如果为空矩阵（[]），那么imshow函数将自动进行数据标度</p></li><li><p>索引图像，<code>imshow(x,map)</code>对于x的每个个像素，imshow显示存储map中相应行的颜色</p></li><li><p>RGB图像的显示，它直接对颜色进行描述而不使用调色板，格式<code>imshow(RGB)</code>。RGB（：，：，1）　RGB（：，：，2）　　 RGB（：，：，3）</p></li><li><p>特殊显示，如多幅图像的显示，需要显示多幅图像时。可以使用<code>figure</code>语句，它的功能就是重新打开一个图像显示窗口</p><p>例:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">I=imread(‘小丑.tif’);<br>Imshow(I);<br>J=imread(‘sunny.tif’);<br><span class="hljs-built_in">figure</span>,imshow(J);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202305041925380.png" alt="image-20230504192518215"></p></li><li><p>也可以将多幅图像显示在同一个单独的图像窗口中</p><p><code>subplot(m,n,p)</code>这种格式将图形窗口划分为m*n个矩形显示区域并激活第p个(先从左往右,再从上往下)显示区域。</p><p>有两种方法:</p><p>法一:联合<code>imshow</code>和<code>subplot</code>函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>),imshow(S)<br>&gt;&gt; subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),imshow(I)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202305041933874.png" alt="image-20230504193358789"></p><p>法二:联合使用<code>subimage</code>函数和<code>subplot</code>函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>),subimage(S)<br>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),subimage(I)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202305041936618.png" alt="image-20230504193621537"></p></li></ul></li><li><p><code>imhist()</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">imhist函数来计算和显示图像的直方图<br>语法格式:<br>imhist(I,n)<br>imhist(X,map)<br><br>imhist(I,n)计算和显示灰度图像I的直方图，n为指定的灰度级数目，默认值为<span class="hljs-number">256</span><br>imhist(X,map)计算和显示索引色图像X的直方图，map为调色板<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202305041942009.png" alt="image-20230504194235956"></p></li><li><p><code>imadjust()</code></p><p>对比度增强</p><p>如果原图像f(x,y)的灰度范围是[m，M]，我们希望调整后的图像g(x,y)的灰度范围是[n，N]，那么下述变换， ，就可以实现这一要求</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">imadjust函数，可以实现上述的线性变换对比度增强<br>语法格式:<br>J = imadjust(I,[low_in high_in],[low_out high_out])<br>返回图像I经过直方图调整后的图像J<br><br><br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">J = imadjust(S,[<span class="hljs-number">0.3</span> <span class="hljs-number">0.7</span>],[]);<br>imshow(S),<span class="hljs-built_in">figure</span>, imshow(J)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202305041954947.png" alt="image-20230504195401762"></p></li><li><p><code>im2bw()</code></p><p>将灰度图像转换为二值图像</p></li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">BW = im2bw(I,level)<br><br>　　将灰度图像 I 转换为二进制图像。输出图像 BW 将输入图像中亮度值大于 level 的像素替换为值<span class="hljs-number">1</span> (白色)，其他替换为值<span class="hljs-number">0</span>(黑色)。你指定 level 在 [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]之间，不用管输入图像的等级。函数graythresh 能用来自动计算变量 level 。如果你不指定 level ，im2bw 使用 <span class="hljs-number">0.5</span>。<br><br><br>BW = im2bw(X,map,level)<br><br>将颜色表为 map 的索引图像 X 转换为二进制图像。<br><br><br>BW = im2bw(RGB,level)<br><br>将 RGB 真彩图像转换为二进制图像。Level是归一化的阈值，值域为[<span class="hljs-number">0</span>，<span class="hljs-number">1</span>]。Level可以由函数graythresh（I）来计算。<br>【如果输入图像不是灰度图像， im2bw 首先将图像转换为灰度图像，然后通过阈值将灰度图像转换成二进制图像。】<br></code></pre></td></tr></table></figure><table><thead><tr><th>函数名</th><th>功能描述</th></tr></thead><tbody><tr><td>Imabsdiff</td><td>两幅图像的绝对差值</td></tr><tr><td>Imadd</td><td>两幅图像的加法</td></tr><tr><td>Imcomplement</td><td>补足一幅图像</td></tr><tr><td>Imdivide</td><td>两幅图像的除法</td></tr><tr><td>Imlincomb</td><td>计算两幅图像的线性组合</td></tr><tr><td>Immultiply</td><td>两幅图像的乘法</td></tr><tr><td>imsubtract</td><td>两幅图像的减法</td></tr></tbody></table><ol start="8"><li><p><code>imadd()</code></p><p>进行两幅图像的加法，或者给一幅图像加上一个常数</p><p>imadd函数将某一幅输入图像的每一个像素值与另一幅图像相应的像素值相加，返回相应的像素值之和作为输出图像</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%语法格式如下:</span><br>Z = imadd（X，Y）<br><span class="hljs-comment">%X和Y表示需要相加的两幅图像，返回值Z表示得到的加法操作结果</span><br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">Cman=imread(<span class="hljs-string">&#x27;cameraman.tif&#x27;</span>);<br>HCman=imadd(Cman,<span class="hljs-number">50</span>);<br>LCman=imadd(Cman,<span class="hljs-number">-50</span>);<br><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>),imshow(LCman);<br>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>),imshow(Cman);<br>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>),imshow(HCman);<br></code></pre></td></tr></table></figure><p>结果展示:</p><p><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202305081729811.png" alt="image-20230508172944715"></p></li><li><p><code>imsubtract()</code></p><p>imsubtract函数可以将一幅图像从另一幅图像中减去，或者从一幅图像中减去一个常数</p><p>imsubtract函数将一幅输入图像的像素值从另一幅输入图像相应的像素值中减去，再将这个结果作为输出图像相应的像素值</p></li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%语法格式:</span><br>Z = imsubtract(X,Y)；<br><span class="hljs-comment">%Z是X-Y操作的结果</span><br></code></pre></td></tr></table></figure><ol start="10"><li><p><code>strel()</code></p><p>structuring element</p><p>运用各种形状和大小构造元素，创建由指定形状shape对应的结构元素。用于膨胀腐蚀及开闭运算等操作的结构元素对象。</p></li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%基本语法:</span><br>SE = strel(shape, parameters)<br>shape 是指定希望形状的字符串，其中shape的种类有<br><span class="hljs-string">&#x27;arbitrary&#x27;</span>,<span class="hljs-string">&#x27;pair&#x27;</span>,<span class="hljs-string">&#x27;diamond&#x27;</span>,<span class="hljs-string">&#x27;periodicline&#x27;</span>,<span class="hljs-string">&#x27;disk&#x27;</span>,<span class="hljs-string">&#x27;rectangle&#x27;</span>,<span class="hljs-string">&#x27;line&#x27;</span>,<span class="hljs-string">&#x27;square&#x27;</span>,<span class="hljs-string">&#x27;octagon&#x27;</span><br>参数parameters是指定形状信息的一系列参数，一般控制SE的大小<br><br><br>SE = strel(<span class="hljs-string">&#x27;arbitrary&#x27;</span>, NHOOD)<br>创建一个任意形状的结构元素，NHOOD是由<span class="hljs-number">0</span>和<span class="hljs-number">1</span>组成的矩阵，用于指定形状可以用se=strel(NHOOD)简化<br><br>创建一个指定领域的平面结构化元素。<span class="hljs-number">1</span>的位置定义了领域的形态学操作。NHOOD的中心就是它的中心元素，位置在FLOOR((SIZE(NHOOD) + <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>)。你也可以忽略参数串<span class="hljs-string">&#x27;arbitrary&#x27;</span>而只使用STREL(NHOOD).<br><br>SE = strel(<span class="hljs-string">&#x27;arbitrary&#x27;</span>, NHOOD, HEIGHT)<br>创建一个指定领域的非平面结构化元素。HEIGHT是一个矩阵，大小和NHOOD相同，他指定了NHOOD中任何非零元素的高度值。HEIGHT必须是实有限值。你也可以忽略参数串<span class="hljs-string">&#x27;arbitrary&#x27;</span>而只使用STREL(NHOOD,HEIGHT).<br>creates a nonflat, ball-shaped structuring element (actually an ellipsoid) whose radius in the X-Y plane is R and whose height is H.<br>When N is greater than <span class="hljs-number">0</span>, the ball-shaped structuring element is approximated by a sequence of Nnonflat, line-shaped structuring elements. When N equals <span class="hljs-number">0</span>, no approximation is used, and the structuring element members consist of all pixels whose centers are no greater than R away from the origin.<br><br>例子：<br><br>se1 = strel(<span class="hljs-string">&#x27;square&#x27;</span>,<span class="hljs-number">6</span>) <span class="hljs-comment">% 创建6*6的正方形</span><br><br> <br><br>SE = strel(<span class="hljs-string">&#x27;line&#x27;</span>, LEN, DEG) 创建一个平坦的线型结构，LEN长度，DEG角度<br><br>se2 = strel(<span class="hljs-string">&#x27;line&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-number">45</span>) <span class="hljs-comment">% 创建直线长度10，角度45</span><br><br> <br><br>SE = strel(<span class="hljs-string">&#x27;disk&#x27;</span>, R, N)<br><br>创建一个指定半径R的平面圆盘形的结构元素。这里R必须是非负整数. N须是<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8.</span>当N大于<span class="hljs-number">0</span>时,圆盘形结构元素由一组N(或N+<span class="hljs-number">2</span>)个周期线型（ periodic-line ）结构元素来近似。当N等于<span class="hljs-number">0</span>时,不使用近似，即结构元素的所有像素是由到中心像素距离小于等于R的像素组成。N可以被忽略,此时缺省值是<span class="hljs-number">4</span>。<br><br>注: 形态学操作在N&gt;<span class="hljs-number">0</span>情况下要快于N=<span class="hljs-number">0</span>的情形。<br><br>se3 = strel(<span class="hljs-string">&#x27;disk&#x27;</span>,<span class="hljs-number">15</span>) <span class="hljs-comment">% 创建圆盘半径15</span><br><br> <br><br>SE = STREL(<span class="hljs-string">&#x27;ball&#x27;</span>,R,H,N) 创建一个空间椭球状的结构元素，其X-Y平面半径为R，高度为H。R必须为非负整数，H是一个实数。N必须为一个非负偶数，当N&gt;<span class="hljs-number">0</span>时此球形结构元素由一系列空间线段结构元素来近似；当N=<span class="hljs-number">0</span>时不需要近似，结构化元素的成员由所有中心距圆点&gt;R的元素组成，相应的高度值可由R/H指定的椭球中提取。如果N未指定，缺省值<span class="hljs-number">8</span>，并且。注: 使用球体近似的形态学操作N&gt;<span class="hljs-number">0</span>的情况要比N=<span class="hljs-number">0</span>的情况快许多。<br>se4 = strel(<span class="hljs-string">&#x27;ball&#x27;</span>,<span class="hljs-number">15</span>,<span class="hljs-number">5</span>)<br><br><span class="hljs-comment">% 创建椭圆体，半径15，高度5</span><br><br> <br><br>SE = strel(<span class="hljs-string">&#x27;octagon&#x27;</span>, R) 创建一个平坦的八边形结构元素，R是从结构元素原点到八边形边的距离，沿水平轴和垂直轴的度量，R必须是<span class="hljs-number">3</span>的非负倍数<br><br> <br><br>SE = strel(<span class="hljs-string">&#x27;pair&#x27;</span>, OFFSET) 创建一个包含两个成员的平坦结构元素，一个成员在原点，另一个成员由向量OFFSET表示，该向量必须是一个两元素的整数向量<br><br> <br><br>SE = strel(<span class="hljs-string">&#x27;diamond&#x27;</span>, R)<br>创建一个指定大小R平面钻石形状的结构化元素。R是从结构化元素原点到其点的距离，必须为非负整数。<br><br><br>SE = strel(<span class="hljs-string">&#x27;periodicline&#x27;</span>, P, V) 创建一个包含有<span class="hljs-number">2</span>*P+<span class="hljs-number">1</span>个成员的平坦元素，其中V是一个两元素向量，它包含有整数值的行和列的偏移，一个元素在原点，另一个位于 <span class="hljs-number">1</span>*V, <span class="hljs-number">-1</span>*V, <span class="hljs-number">2</span>*V, <span class="hljs-number">-2</span>*V, ..., P*V, -P*V.<br><br> <br><br>SE = strel(<span class="hljs-string">&#x27;rectangle&#x27;</span>, MN) 创建一个平坦的矩形结构，MN指定大小  SE = strel(<span class="hljs-string">&#x27;square&#x27;</span>, W) 创建一个方形的结构元素，边长为N个像素<br><br> <br><br>Nhood=getnhood（se）<span class="hljs-comment">%获得se邻域</span><br></code></pre></td></tr></table></figure><p>两幅图像进行乘法运算可以实现掩模操作，即屏蔽掉图像的某些部分。一幅图像乘以一个常数通常被称为缩放</p><ol start="11"><li><code>immulitply(X,Y)</code></li></ol><p>将两幅图像相应的像素值进行元素对元素的乘法操作（MATLAB点乘），并将乘法的运算结果作为输出图形相应的像素值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%语法格式:</span><br>Z = immulitply(X,Y)<br><br></code></pre></td></tr></table></figure><ol start="12"><li><p><code>ind2gray()</code></p><p>索引图像转换为灰度图像</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%语法格式</span><br>I = ind2gray(X,cmap)<br><span class="hljs-comment">%将X带有颜色图 的索引图像转换cmap为灰度图像I,</span><br><span class="hljs-comment">%该 ind2gray功能在保持亮度的同时从输入图像中删除色相和饱和度信息。</span><br></code></pre></td></tr></table></figure><p>eg:</p></li></ol><p>除法运算可用于校正成像设备的非线性影响，这在特殊形态的图像（如断层扫描等医学图像）处理中常常用到。图像除法也可以用来检测两幅图像间的区别，但是除法操作给出的是相应像素值的变化比率，而不是每个像素的绝对差异，因而图像除法也称为比率变换。</p><ol start="13"><li><p><code>imdivide()</code></p><p>imdivide函数对两幅输入图像的所有相应像素执行元素对元素的除法操作（点除），并将得到的结果作为输出图像的相应像素值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%语法格式</span><br>Z = imdivide(X,Y)<br><span class="hljs-comment">%Z=X/Y</span><br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jotang招新8-1</title>
    <link href="/2022/10/23/jotang%E6%8B%9B%E6%96%B08-1/"/>
    <url>/2022/10/23/jotang%E6%8B%9B%E6%96%B08-1/</url>
    
    <content type="html"><![CDATA[<h1>🔥安装Anaconda</h1><p>嘛~这一步没有想象中的顺利,先找了教程大概看了一下觉得没什么问题,就直接大胆安装了,用的是<a src=" [Index of /anaconda/archive/](http://link.zhihu.com/?target=https%3A//mirrors.tuna.tsinghua.edu.cn/anaconda/archive/)">清华源</a>,一路下来完成后输入<code>conda</code>,就报错了捏</p><p>查找原因应是电脑上已经有python</p><p>于是一不做二不休,把他给卸了,环境变量里也先给删除</p><p>然后就好了</p><p><img src="/img/image-20221016235121660.png"></img></p><h1>按照招新题的提示稍微了解神经网络的基本概念和pytorch等</h1><ul><li><p>神经网络的基本概念:</p><blockquote><p>官网定义如下:神经网络是一种运算模型，由大量的节点（或称神经元）之间相互联接构成。每个节点代表一种特定的输出函数，称为激励函数（activation function）。每两个节点间的连接都代表一个对于通过该连接信号的加权值，称之为权重，这相当于人工神经网络的记忆。网络的输出则依网络的连接方式，权重值和激励函数的不同而不同。而网络自身通常都是对自然界某种算法或者函数的逼近，也可能是对一种逻辑策略的表达。</p></blockquote></li><li><p>pytorch是什么:</p><p>大概康了康,pytorch是一个深度学习的框架,</p></li></ul><h2 id="监督学习-无监督学习">监督学习/无监督学习</h2><ul><li>监督学习<strong>supervised learning</strong>:监督学习是学习一个模型,让模型能够对任意给定的输入,对他的输出做一个预测,直白点就是用训练集训练,然后用模型测试样本集</li><li>无监督学习<strong>unsupervised learning</strong>:没有给定的标准,自动对输入的资料进行分类,然后寻找模型和规律,也就是说在学习的过程中，每个训练元组的类标号是未知的，并且通过学习所形成的类的个数或集合也不知道。典型的无监督学习：聚类等</li></ul><p>监督学习需要每个样本都有标签，无监督学习则不需要。所以后面也出现了弱监督学习和半监督学习，并非所有样本都有标签。</p><h2 id="分类器-预测器">分类器/预测器</h2><ul><li>分类器:</li></ul><p>分类器是数据挖掘中对样本进行分类的方法的统称，包含决策树，逻辑回归，朴素贝叶斯，神经网络等 分类器的构造和实施大体会经过以下几个步骤： 选定样本（包含正样本和负样本），将所有样本分成训练样本和测试样本两部分。 在训练样本上执行分类器算法，生成分类模型。 在测试样本上执行分类模型，生成预测结果。 根据预测结果，计算必要的评估指标，评估分类模型的性能。 几种基本的分类器： 决策树分类器；选择树分类器；证据分类器—选择树分类器与决策树分类器比较相近，但是前者在选择节点处可以考虑多种情况，将多种因素放入一个选择节点中，而决策树分类器一个节点一次最多只能选取一个属性作为考虑对象。 证据分类器就是通过检查在一个给定属性上某个特定的结果发生的可能性来对数据进行分类。比如一个正在打着一把伞的人，有70%是女性，30%是男性。</p><ul><li>预测器: 接收一个简单的输入，做出应有的预测，再输出结果</li></ul><h2 id="独热码">独热码:</h2><p>One-Hot编码，又称为一位有效编码，主要是采用N位状态寄存器来对N个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候只有一位有效。</p><p>他可以将定性的数据编码为定量的数据</p><p>在机器学习中广泛用于对离散型的分类数据预处理操作。如特征性别，即可分为三类：男、女和其他。用计算机二进制表达（[1,0,0],[0,1,0],[0,0,1]）</p><p>one-hot编码详解参考的是下面这篇文章:</p><p><a href="https://cloud.tencent.com/developer/article/1688022">机器学习之独热编码（One-Hot）详解（代码解释）</a></p><h2 id="向量化">向量化</h2><ul><li>可以将高度重复的计算组织成 并行的向量运算，对于 简化代码，加速运算 有着非常重要的作用。简单来说就像是把多次for循环变成一次计算</li></ul><h2 id="神经元-输入层-隐藏层-输出层">神经元/输入层/隐藏层/输出层</h2><ul><li><p>神经元：是构成神经网络的基本单元。就像是人脑里的神经元，接受输入信号，并产生输出</p><p><img src="/img/ml (2).png"></img></p></li><li><p>输入层/隐藏层/输出层:上面是一个经典的神经网络,红色的是输入层,绿色的代表输出层,紫色的是隐藏层,也叫做中间层</p></li></ul><p>参考链接如下:</p><p><a href="https://www.cnblogs.com/subconscious/p/5058741.html">神经网络浅讲：从神经元到深度学习</a></p><h2 id="卷积convolution">卷积<em><strong>convolution</strong></em></h2><blockquote><p>从百度上抄了个定义:在泛函分析中，卷积、旋积或褶积(英语：Convolution)是通过两个函数 f和g生成第三个函数的一种数学运算，其本质是一种特殊的积分变换，表征函数f与g经过翻转和平移的重叠部分函数值乘积对重叠长度的积分。</p></blockquote><p>有点抽象</p><p>目前我觉得他就是一种运算方法,就像加减乘除一样</p><p>“卷”是指函数翻转,也有滑动的意味?</p><p>“积”是指积分/加权求和</p><p><a href="https://www.eet-china.com/mp/a109236.html">很详细的讲解什么以及为什么是卷积（Convolution）-面包板社区</a></p><h2 id="激活函数">激活函数</h2><p>抄来的定义:</p><blockquote><p>激活函数（Activation Function）是一种添加到人工神经网络中的函数，旨在帮助网络学习数据中的复杂模式。类似于人类大脑中基于神经元的模型，激活函数最终决定了要发射给下一个神经元的内容。</p></blockquote><blockquote><p>在人工神经网络中，一个节点的激活函数定义了该节点在给定的输入或输入集合下的输出。</p></blockquote><p>我目前理解是:激活函数就是一个用于神经网络中的函数,这个函数接收输入的数据,然后产生输出数据,并输出发送给下一个神经元。</p><p>参考链接:</p><p>[深度学习领域最常用的10个激活函数，一文详解数学原理及优缺点](<a href="https://finance.sina.com.cn/tech/2021-02-24/doc-ikftssap8455930.shtml#:~:text=%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%EF%BC%88Activation">https://finance.sina.com.cn/tech/2021-02-24/doc-ikftssap8455930.shtml#:~:text=激活函数（Activation</a> Function）是,输入集合下的输出。)</p><h2 id="权重-权重更新">权重/权重更新</h2><ul><li>权重：不同神经元的连接被赋予不同的权重，权重代表的是一个节点对另一个节点的影响大小</li><li>权重更新：</li></ul><h2 id="梯度-学习率-损失函数-过拟合">梯度/学习率/损失函数/过拟合</h2><ul><li>梯度:</li><li>学习率:</li><li>损失函数：这是一个非负实数函数，用来量化模型预测和真实标签之间的差异。</li><li>过拟合：overfitting，过度拟合。我们的训练样本往往是很小的（和真实情况相比），不能很好的反映全部数据的真实分布，这样就可能使得我们训练出来的模型在我们的训练集上错误率很低，但是对于未知数据错误率就升高了。</li><li>欠拟合: 没有充分学习训练集的特征</li></ul><h2 id="训练集-测试集">训练集/测试集</h2><p>可以把一组样本构成的集合称为数据集，然后数据集呢又可以分为训练集和测试集。<strong>训练集</strong>中的样本是用来训练模型的，<strong>测试集</strong>中的样本用来检验训练好的模型</p><h2 id="神经网络性能评价指标：">神经网络性能评价指标：</h2><p>最常用的是<strong>准确率</strong>，<strong>错误率</strong>，精确率和召回率宏平均，微平均，交叉验证</p><h1>接下来就正式开始做招新题目啦</h1><p>刚开始的时候对这个iris数据集做了一个了解</p><blockquote><p>Iris Data Set（鸢尾属植物数据集）是我现在接触到的历史最悠久的数据集，它首次出现在著名的英国统计学家和生物学家<a href="https://en.wikipedia.org/wiki/Ronald_Fisher">Ronald Fisher</a> 1936年的论文《The use of multiple measurements in taxonomic problems》中，被用来介绍线性判别式分析。在这个数据集中，包括了三类不同的鸢尾属植物：Iris Setosa，Iris Versicolour，Iris Virginica。每类收集了50个样本，因此这个数据集一共包含了150个样本。</p></blockquote><p>这个数据集测量了所有150个样本的4个特征，分别是：</p><ol><li>sepal length（花萼长度）</li><li>sepal width（花萼宽度）</li><li>petal length（花瓣长度）</li><li>petal width（花瓣宽度）</li></ol><p>我们可以直接利用Python中的机器学习包scikit-learn直接导入该数据集</p><p>对数据集的了解到此,接下来就正式试着填完?代码吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#请先根据以下代码先安装好对应的package哦</span><br><span class="hljs-comment">#ps:大致了解各个package的作用而不需要仔细学习每个package的用法</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br> <br><span class="hljs-comment">#获得神奇的iris数据集</span><br>dataset = datasets.load_iris()<br><br><span class="hljs-comment">#善用print功能,观察数据集的特点哦,它分为data和target两个部分,属性和种类分别是用哪些数据表示的呢?想清楚之后就可以继续往下啦!</span><br><span class="hljs-comment">#完善代码:寻找一个合适的函数按照二八比例划分测试集和数据集数据</span><br><span class="hljs-built_in">input</span>, x_test, label, y_test = ?<br><span class="hljs-comment">#完善代码:利用pytorch把数据张量化,</span><br><span class="hljs-built_in">input</span> = torch.FloatTensor(<span class="hljs-built_in">input</span>)<br>label = torch.LongTensor(label)<br>x_test = ?<br>y_test = ?<br> <br>label_size = <span class="hljs-built_in">int</span>(np.array(label.size()))<br> <br><span class="hljs-comment"># 搭建专属于你的神经网络 它有着两个隐藏层,一个输出层</span><br><span class="hljs-comment">#请利用之前所学的知识,填写各层输入输出参数以及激活函数.</span><br><span class="hljs-comment">#两个隐藏层均使用线性模型和relu激活函数 输出层使用softmax函数(dim参数设为1)(在下一行注释中写出softmax函数的作用哦)</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NET</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n_feature, n_hidden1, n_hidden2, n_output</span>):<br>        <span class="hljs-built_in">super</span>(NET, self).__init__()<br>        self.hidden1 = ?<br>        self.relu1 = ?<br> <br>        self.hidden2 =?<br>        self.relu2 = ?<br> <br>        self.out = ?<br>        self.softmax =?<br><span class="hljs-comment">#前向传播函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        hidden1 = self.hidden1(x)<br>        relu1 = self.relu1(hidden1)<br><span class="hljs-comment">#完善代码:</span><br>        hidden2 = ?<br>        relu2 = ?<br> <br>        out = ?<br> <br>        <span class="hljs-keyword">return</span> out<br><span class="hljs-comment">#测试函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">self, x</span>):<br>        y_pred = self.forward(x)<br>        y_predict = self.softmax(y_pred)<br> <br>        <span class="hljs-keyword">return</span> y_predict<br> <br> <br><span class="hljs-comment"># 定义网络结构以及损失函数</span><br><span class="hljs-comment">#完善代码:根据这个数据集的特点合理补充参数,可设置第二个隐藏层输入输出的特征数均为20</span><br>net = NET(n_feature=?, n_hidden1=?, n_hidden2=?, n_output=?)<br><span class="hljs-comment">#选一个你喜欢的优化器</span><br><span class="hljs-comment">#举个例子 SGD优化器 optimizer = torch.optim.SGD(net.parameters(),lr = 0.02)</span><br><span class="hljs-comment">#完善代码:我们替你选择了adam优化器,请补充一行代码</span><br>?<br><span class="hljs-comment">#这是一个交叉熵损失函数,不懂它没关系(^_^)</span><br>loss_func = torch.nn.CrossEntropyLoss()<br>costs = []<br><span class="hljs-comment">#完善代码:请设置一个训练次数的变量(这个神经网络需要训练2000次)</span><br>?<br><span class="hljs-comment"># 训练网络</span><br><span class="hljs-comment">#完善代码:把参数补充完整</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(?):<br>    cost = <span class="hljs-number">0</span><br><span class="hljs-comment">#完善代码:利用forward和损失函数获得out(输出)和loss(损失)</span><br>    out = ?<br>    loss = ?<br><span class="hljs-comment">#请在下一行注释中回答zero_grad这一行的作用</span><br><span class="hljs-comment">#</span><br>    optimizer.zero_grad()<br><span class="hljs-comment">#完善代码:反向传播 并更新所有参数</span><br>    ?<br>    ?<br>    cost = cost + loss.cpu().detach().numpy()<br>    costs.append(cost / label_size)<br><span class="hljs-comment">#可视化</span><br>plt.plot(costs)<br>plt.show()<br> <br><span class="hljs-comment"># 测试训练集准确率</span><br>out = net.test(<span class="hljs-built_in">input</span>)<br>prediction = torch.<span class="hljs-built_in">max</span>(out, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>pred_y = prediction.numpy()<br>target_y = label.numpy()<br>accuracy = <span class="hljs-built_in">float</span>((pred_y == target_y).astype(<span class="hljs-built_in">int</span>).<span class="hljs-built_in">sum</span>()) / <span class="hljs-built_in">float</span>(target_y.size)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集准确率为&quot;</span>, accuracy * <span class="hljs-number">100</span>, <span class="hljs-string">&quot;%&quot;</span>)<br> <br><span class="hljs-comment"># 测试测试集准确率</span><br>out1 = net.test(x_test)<br>prediction1 = torch.<span class="hljs-built_in">max</span>(out1, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>pred_y1 = prediction1.numpy()<br>target_y1 = y_test.numpy()<br> <br>accuracy1 = <span class="hljs-built_in">float</span>((pred_y1 == target_y1).astype(<span class="hljs-built_in">int</span>).<span class="hljs-built_in">sum</span>()) / <span class="hljs-built_in">float</span>(target_y1.size)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试集准确率为&quot;</span>, accuracy1 * <span class="hljs-number">100</span>, <span class="hljs-string">&quot;%&quot;</span>)<br> <br><span class="hljs-comment">#至此,你已经拥有了一个简易的神经网络,运行一下试试看吧</span><br><span class="hljs-comment">#最后,回答几个简单的问题,本次的问题属于监督学习还是无监督学习呢?batch size又是多大呢?像本题这样的batch size是否适用于大数据集呢,原因是?</span><br></code></pre></td></tr></table></figure><p>步骤如下:</p><p><img src="/img/mi03.png"></img></p><h2 id="二八划分测试集与训练集">二八划分测试集与训练集</h2><p>因为题目中已经  <code>from sklearn.model_selection import train_test_split</code>,所以直接通过sklearn实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">input</span>, x_test, label, y_test = train_test_split(dataset, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br><span class="hljs-comment">#random_state:设置随机种子，保证每次运行生成相同的随机数</span><br><span class="hljs-comment">#test_size:将数据分割成训练集的比例</span><br></code></pre></td></tr></table></figure><h2 id="利用pytorch把数据张量化">利用pytorch把数据张量化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">input</span> = torch.FloatTensor(<span class="hljs-built_in">input</span>)<br>label = torch.LongTensor(label)<br>x_test = torch.FloatTensor(x_test)<br>y_test = torch.LongTensor(y_test)<br></code></pre></td></tr></table></figure><h2 id="relu激活函数：">relu激活函数：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">relu(x)=<span class="hljs-built_in">max</span> (x,<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><blockquote><p>相比于其它激活函数来说，ReLU有以下优势：对于线性函数而言，ReLU的表达能力更强，尤其体现在深度网络中；而对于非线性函数而言，ReLU由于非负区间的梯度为常数，因此不存在梯度消失问题(Vanishing Gradient Problem)，使得模型的收敛速度维持在一个稳定状态。这里稍微描述一下什么是梯度消失问题：当梯度小于1时，预测值与真实值之间的误差每传播一层会衰减一次，如果在深层模型中使用sigmoid作为激活函数，这种现象尤为明显，将导致模型收敛停滞不前。<br>————————————————<br>版权声明：本文为CSDN博主「对半独白」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/cherrylvlei/article/details/53149381">https://blog.csdn.net/cherrylvlei/article/details/53149381</a></p></blockquote><h2 id="搭建神经网络-2个隐藏层1个输出层">搭建神经网络(2个隐藏层1个输出层)</h2><p>代码补充到这里的时候发现前面的了解实在太过于浅显，于是又去看了隐藏层输出层相关的具体知识</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>jotang招新8-2.1</title>
    <link href="/2022/10/23/jotang%E6%8B%9B%E6%96%B08-2-1/"/>
    <url>/2022/10/23/jotang%E6%8B%9B%E6%96%B08-2-1/</url>
    
    <content type="html"><![CDATA[<h1>目标:</h1><p class = "note note-success">复现此项目:    <a href="https://data-flair.training/blogs/create-emoji-with-deep-learning/">识别自己的表情符号</a></p><h1><code>train.py</code></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> keras.emotion_models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense, Dropout, Flatten<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Conv2D<br><span class="hljs-keyword">from</span> keras.optimizers <span class="hljs-keyword">import</span> Adam<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> MaxPooling2D<br><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword">import</span> ImageDataGenerator<br><br>train_dir = <span class="hljs-string">&#x27;venv/train&#x27;</span><br>val_dir = <span class="hljs-string">&#x27;venv/test&#x27;</span><br><br><span class="hljs-comment"># ImageDataGenerator图片处理生成器</span><br>train_datagen = ImageDataGenerator(rescale=<span class="hljs-number">1.</span>/<span class="hljs-number">255</span>)<br>val_datagen = ImageDataGenerator(rescale=<span class="hljs-number">1.</span>/<span class="hljs-number">255</span>)<br><br>train_generator = train_datagen.flow_from_directory(<br>        train_dir,<br>        target_size=(<span class="hljs-number">48</span>,<span class="hljs-number">48</span>),  <span class="hljs-comment"># 默认图片大小为256*256,现在调整为48*48</span><br>        batch_size=<span class="hljs-number">64</span>,<br>        color_mode=<span class="hljs-string">&quot;gray_framescale&quot;</span>,  <span class="hljs-comment"># 颜色模式，默认RGB，设置为灰度为单通道的图片</span><br>        class_mode=<span class="hljs-string">&#x27;categorical&#x27;</span>)  <span class="hljs-comment"># 决定返回的标签数组的类型</span><br><br>validation_generator = val_datagen.flow_from_directory(<br>        val_dir,<br>        target_size=(<span class="hljs-number">48</span>,<span class="hljs-number">48</span>),<br>        batch_size=<span class="hljs-number">64</span>,<br>        color_mode=<span class="hljs-string">&quot;gray_framescale&quot;</span>,<br>        class_mode=<span class="hljs-string">&#x27;categorical&#x27;</span>)<br><br><span class="hljs-comment"># Sequential序贯模型</span><br>emotion_model = Sequential()<br><span class="hljs-comment"># 第一层需要指出输入的形状(样本数，行，列，通道数)，只指出后三维即可，第一维按batch_size自动指定</span><br><span class="hljs-comment"># 卷积中滤波器的数量为32，即输出空间的维度</span><br><span class="hljs-comment"># kernel_size 卷积核大小</span><br><br>emotion_model.add(Conv2D(<span class="hljs-number">32</span>, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, input_shape=(<span class="hljs-number">48</span>,<span class="hljs-number">48</span>,<span class="hljs-number">1</span>)))<br>emotion_model.add(Conv2D(<span class="hljs-number">64</span>, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br><span class="hljs-comment"># 最大池化层</span><br>emotion_model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br><span class="hljs-comment"># 丢弃率</span><br>emotion_model.add(Dropout(<span class="hljs-number">0.25</span>))<br>emotion_model.add(Conv2D(<span class="hljs-number">128</span>, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>emotion_model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br>emotion_model.add(Conv2D(<span class="hljs-number">128</span>, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>emotion_model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br>emotion_model.add(Dropout(<span class="hljs-number">0.25</span>))<br><br>emotion_model.add(Flatten())<br>emotion_model.add(Dense(<span class="hljs-number">1024</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>emotion_model.add(Dropout(<span class="hljs-number">0.5</span>))<br><span class="hljs-comment"># 最终输出七类</span><br>emotion_model.add(Dense(<span class="hljs-number">7</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>))<br><span class="hljs-comment"># emotion_model.load_weights(&#x27;emotion_model.h5&#x27;)</span><br><br><span class="hljs-comment"># Using openCV haarcascade xml detect the bounding boxes of face in the webcam and predict the emotions:</span><br>cv2.ocl.setUseOpenCL(<span class="hljs-literal">False</span>)<br><br>emotion_dict = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&quot;Angry&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;Disgusted&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;Fearful&quot;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;Happy&quot;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&quot;Neutral&quot;</span>, <span class="hljs-number">5</span>: <span class="hljs-string">&quot;Sad&quot;</span>, <span class="hljs-number">6</span>: <span class="hljs-string">&quot;Surprised&quot;</span>&#125;<br><br><span class="hljs-comment"># 编译训练模式</span><br>emotion_model.<span class="hljs-built_in">compile</span>(loss=<span class="hljs-string">&#x27;categorical_crossentropy&#x27;</span>,optimizer=Adam(lr=<span class="hljs-number">0.0001</span>, decay=<span class="hljs-number">1e-6</span>),metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br>emotion_model_info = emotion_model.fit_generator(<br>        train_generator,<br>        steps_per_epoch=<span class="hljs-number">28709</span> // <span class="hljs-number">64</span>,<br>        epochs=<span class="hljs-number">50</span>,<br>        validation_data=validation_generator,<br>        validation_steps=<span class="hljs-number">7178</span> // <span class="hljs-number">64</span>)<br><span class="hljs-comment"># 保存模型参数</span><br>emotion_model.save_weights(<span class="hljs-string">&#x27;emotion_model.h5&#x27;</span>)<br><br><span class="hljs-comment"># start the webcam feed</span><br>cap = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># Find haar cascade to draw bounding box around face</span><br>    ret, frame = cap.read()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ret:<br>        <span class="hljs-keyword">break</span><br><br>    bounding_box = cv2.CascadeClassifier(<span class="hljs-string">&#x27;/home/shivam/.local/lib/python3.6/site-packages/cv2/data/haarcascade_frontalface_default.xml&#x27;</span>)<br>    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2gray_frame)<br>    num_faces = bounding_box.detectMultiScale(gray_frame,scaleFactor=<span class="hljs-number">1.3</span>, minNeighbors=<span class="hljs-number">5</span>)<br><br>    <span class="hljs-keyword">for</span> (x, y, w, h) <span class="hljs-keyword">in</span> num_faces:<br>        cv2.rectangle(frame, (x, y-<span class="hljs-number">50</span>), (x+w, y+h+<span class="hljs-number">10</span>), (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br>        roi_gray_frame = gray_frame[y:y + h, x:x + w]<br>        cropped_img = np.expand_dims(np.expand_dims(cv2.resize(roi_gray_frame, (<span class="hljs-number">48</span>, <span class="hljs-number">48</span>)), -<span class="hljs-number">1</span>), <span class="hljs-number">0</span>)<br>        emotion_prediction = emotion_model.predict(cropped_img)<br>        maxindex = <span class="hljs-built_in">int</span>(np.argmax(emotion_prediction))<br>        cv2.putText(frame, emotion_dict[maxindex], (x+<span class="hljs-number">20</span>, y-<span class="hljs-number">60</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="hljs-number">1</span>, (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>, cv2.LINE_AA)<br><br>    cv2.imshow(<span class="hljs-string">&#x27;Video&#x27;</span>, cv2.resize(frame,(<span class="hljs-number">1200</span>,<span class="hljs-number">860</span>),interpolation = cv2.INTER_CUBIC))<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>        <span class="hljs-keyword">break</span><br><br>cap.release()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><h1><code>gui.py</code></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image, ImageTk<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense, Dropout, Flatten<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Conv2D<br><span class="hljs-keyword">from</span> keras.optimizers <span class="hljs-keyword">import</span> Adam<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> MaxPooling2D<br><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword">import</span> ImageDataGenerator<br><span class="hljs-keyword">import</span> os<br><br>emotion_model = Sequential()<br><br>emotion_model.add(Conv2D(<span class="hljs-number">32</span>, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, input_shape=(<span class="hljs-number">48</span>, <span class="hljs-number">48</span>, <span class="hljs-number">1</span>)))<br>emotion_model.add(Conv2D(<span class="hljs-number">64</span>, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>emotion_model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br>emotion_model.add(Dropout(<span class="hljs-number">0.25</span>))<br><br>emotion_model.add(Conv2D(<span class="hljs-number">128</span>, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>emotion_model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br>emotion_model.add(Conv2D(<span class="hljs-number">128</span>, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>emotion_model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br>emotion_model.add(Dropout(<span class="hljs-number">0.25</span>))<br><br>emotion_model.add(Flatten())<br>emotion_model.add(Dense(<span class="hljs-number">1024</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>emotion_model.add(Dropout(<span class="hljs-number">0.5</span>))<br>emotion_model.add(Dense(<span class="hljs-number">7</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>))<br>emotion_model.load_weights(<span class="hljs-string">&#x27;emotion_model.h5&#x27;</span>)<br><br>cv2.ocl.setUseOpenCL(<span class="hljs-literal">False</span>)<br><br>emotion_dict = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&quot;   Angry   &quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;Disgusted&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;  Fearful  &quot;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;   Happy   &quot;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&quot;  Neutral  &quot;</span>,<br>                <span class="hljs-number">5</span>: <span class="hljs-string">&quot;    Sad    &quot;</span>, <span class="hljs-number">6</span>: <span class="hljs-string">&quot;Surprised&quot;</span>&#125;<br><br>emoji_dist = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&quot;./emojis/angry.png&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;./emojis/disgusted.png&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;./emojis/fearful.png&quot;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;./emojis/happy.png&quot;</span>,<br>              <span class="hljs-number">4</span>: <span class="hljs-string">&quot;./emojis/neutral.png&quot;</span>, <span class="hljs-number">5</span>: <span class="hljs-string">&quot;./emojis/sad.png&quot;</span>, <span class="hljs-number">6</span>: <span class="hljs-string">&quot;./emojis/surpriced.png&quot;</span>&#125;<br><br><span class="hljs-keyword">global</span> last_frame1<br>last_frame1 = np.zeros((<span class="hljs-number">480</span>, <span class="hljs-number">640</span>, <span class="hljs-number">3</span>), dtype=np.uint8)<br><span class="hljs-keyword">global</span> cap1<br>show_text = [<span class="hljs-number">0</span>]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_vid</span>():<br>    <span class="hljs-comment"># 打开摄像头</span><br>    cap1 = cv2.VideoCapture(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cap1.isOpened():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;cant open the camera1&quot;</span>)<br><br>    flag1, frame1 = cap1.read()  <span class="hljs-comment"># 捕获帧信息函数，flag1返回布尔值，frame1返回捕获的帧信息（图像）</span><br>    frame1 = cv2.resize(frame1, (<span class="hljs-number">600</span>, <span class="hljs-number">500</span>))  <span class="hljs-comment"># 把frame1图片缩放</span><br><br>    <span class="hljs-comment"># 改为级联分类的地址</span><br>    bounding_box = cv2.CascadeClassifier(<br>        <span class="hljs-string">&#x27;D:/Anaconda/envs/pytorch/Lib/site-packages/cv2/data/haarcascade_frontalface_default.xml&#x27;</span>)<br>    <span class="hljs-comment"># 转为灰度图</span><br>    gray_frame = cv2.cvtColor(frame1, cv2.COLOR_BGR2GRAY)<br><br>    <span class="hljs-comment"># # detectMultiScale(待检测图像，scaleFactor前后两次相继的扫描中搜索框的比例系数，默认为1.1即每次搜索框扩大10%,</span><br>    <span class="hljs-comment"># minNeighbors表示每一个目标至少要被检测到5次才算是真的目标(因为周围的像素和不同的窗口大小都可以检测到人脸)) 返回人脸</span><br>    num_faces = bounding_box.detectMultiScale(gray_frame, scaleFactor=<span class="hljs-number">1.3</span>, minNeighbors=<span class="hljs-number">5</span>)<br><br>    <span class="hljs-keyword">for</span> (x, y, w, h) <span class="hljs-keyword">in</span> num_faces:<br>        <span class="hljs-comment"># 在frame上画矩形</span><br>        cv2.rectangle(frame1, (x, y - <span class="hljs-number">50</span>), (x + w, y + h + <span class="hljs-number">10</span>), (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br>        roi_gray_frame = gray_frame[y:y + h, x:x + w]<br>        cropped_img = np.expand_dims(np.expand_dims(cv2.resize(roi_gray_frame, (<span class="hljs-number">48</span>, <span class="hljs-number">48</span>)), -<span class="hljs-number">1</span>), <span class="hljs-number">0</span>)<br>        prediction = emotion_model.predict(cropped_img)<br><br>        maxindex = <span class="hljs-built_in">int</span>(np.argmax(prediction))<br>        <span class="hljs-comment"># putText添加文字 (图片，添加的文字，左上角坐标，字体，字体大小，颜色，字体粗细)</span><br>        <span class="hljs-comment"># cv2.putText(frame1, emotion_dict[maxindex], (x+20, y-60), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2, cv2.LINE_AA)</span><br>        show_text[<span class="hljs-number">0</span>] = maxindex<br>    <span class="hljs-keyword">if</span> flag1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Major error!&quot;</span>)<br>    <span class="hljs-keyword">elif</span> flag1:<br>        <span class="hljs-keyword">global</span> last_frame1<br>        last_frame1 = frame1.copy()<br>        pic = cv2.cvtColor(last_frame1, cv2.COLOR_BGR2RGB)<br>        img = Image.fromarray(pic)<br>        imgtk = ImageTk.PhotoImage(image=img)<br>        lmain.imgtk = imgtk<br>        lmain.configure(image=imgtk)<br>        lmain.after(<span class="hljs-number">10</span>, show_vid)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>        exit()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_vid2</span>():<br>    <span class="hljs-comment"># 读入的是array</span><br>    frame2 = cv2.imread(emoji_dist[show_text[<span class="hljs-number">0</span>]])<br>    pic2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2RGB)<br>    <span class="hljs-comment"># 将array转换为image</span><br>    img2 = Image.fromarray(frame2)<br>    imgtk2 = ImageTk.PhotoImage(image=img2)<br>    lmain2.imgtk2 = imgtk2<br>    lmain3.configure(text=emotion_dict[show_text[<span class="hljs-number">0</span>]], font=(<span class="hljs-string">&#x27;arial&#x27;</span>, <span class="hljs-number">45</span>, <span class="hljs-string">&#x27;bold&#x27;</span>))<br><br>    lmain2.configure(image=imgtk2)<br>    lmain2.after(<span class="hljs-number">10</span>, show_vid2)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    root = tk.Tk()<br><br>    img = ImageTk.PhotoImage(Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data/logo.png&#x27;</span>))<br><br>    <span class="hljs-built_in">print</span>(img)<br><br>    heading = Label(root, image=img, bg=<span class="hljs-string">&#x27;black&#x27;</span>)<br><br>    heading.pack()<br>    heading2 = Label(root, text=<span class="hljs-string">&quot;Photo to Emoji&quot;</span>, pady=<span class="hljs-number">20</span>, font=(<span class="hljs-string">&#x27;arial&#x27;</span>, <span class="hljs-number">45</span>, <span class="hljs-string">&#x27;bold&#x27;</span>), bg=<span class="hljs-string">&#x27;black&#x27;</span>, fg=<span class="hljs-string">&#x27;#CDCDCD&#x27;</span>)<br><br>    heading2.pack()<br>    lmain = tk.Label(master=root, padx=<span class="hljs-number">50</span>, bd=<span class="hljs-number">10</span>)<br>    lmain2 = tk.Label(master=root, bd=<span class="hljs-number">10</span>)<br><br>    lmain3 = tk.Label(master=root, bd=<span class="hljs-number">10</span>, fg=<span class="hljs-string">&quot;#CDCDCD&quot;</span>, bg=<span class="hljs-string">&#x27;black&#x27;</span>)<br>    lmain.pack(side=LEFT)<br>    lmain.place(x=<span class="hljs-number">50</span>, y=<span class="hljs-number">250</span>)<br>    lmain3.pack()<br>    lmain3.place(x=<span class="hljs-number">960</span>, y=<span class="hljs-number">250</span>)<br>    lmain2.pack(side=RIGHT)<br>    lmain2.place(x=<span class="hljs-number">900</span>, y=<span class="hljs-number">350</span>)<br><br>    root.title(<span class="hljs-string">&quot;Photo To Emoji&quot;</span>)<br>    root.geometry(<span class="hljs-string">&quot;1400x900+100+10&quot;</span>)<br>    root[<span class="hljs-string">&#x27;bg&#x27;</span>] = <span class="hljs-string">&#x27;black&#x27;</span><br>    exitbutton = Button(root, text=<span class="hljs-string">&#x27;Quit&#x27;</span>, fg=<span class="hljs-string">&quot;red&quot;</span>, command=root.destroy, font=(<span class="hljs-string">&#x27;arial&#x27;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;bold&#x27;</span>)).pack(side=BOTTOM)<br>    show_vid()<br>    show_vid2()<br>    root.mainloop()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓端入门学习及记录</title>
    <link href="/2022/10/21/%E5%AE%89%E5%8D%93%E7%AB%AF%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E5%8F%8A%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/10/21/%E5%AE%89%E5%8D%93%E7%AB%AF%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E5%8F%8A%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p class = "note note-info">这里放置着综设学习安卓端的记录</p><hr><p>第一章主要就是做一个介绍,让我们知道对应文件是大概干什么的</p><p>我们重点要关注的是<code>app</code>这个文件夹下面的内容.(代码是写在<code>app</code>-&gt;<code>src</code>-&gt;<code>main</code>-&gt;<code>java</code>下面)</p><h2 id="论一个项目到底是怎么跑起来的呢-❓❓❓">论一个项目到底是怎么跑起来的呢 ❓❓❓</h2><ul><li><p>让我们首先看到<code>AndroidManifest.xml</code>这个文件</p><p><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202211051320303.png" alt="202211041958683"></p></li></ul><p>活动需要在这里注册,<strong>没有在此注册的活动不能使用</strong>,其中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;action android:name=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;<br>     &lt;category android:name=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>表示MainActivity是这个项目的主活动，在手机上点击应用图标，首先启动的就是这个活动。</p><ul><li><p>再来看到<code>app</code>-&gt;<code>src</code>-&gt;<code>main</code>-&gt;<code>java</code>-&gt;<code>com/example/helloworld</code>-&gt;<code>MainActivity.java</code></p><p>里面有一个 <code>onCreate()</code>方法,<strong>这个方法是一个活动被创建时必定要执行的方法</strong>,</p><p><code>onCreate</code>方法中又有一个<code>setContentView()</code>方法,<strong>这个方法给当前活动引入了一个<code>activity_main</code>布局</strong></p>  <p class="note note-info">android中逻辑和视图分离,所以并不在活动中直接编写界面,而在布局文件中编写</p></li><li><p><strong>布局文件</strong>放置在<code>main</code>-&gt;<code>res</code>-&gt;<code>layout</code>下面</p></li><li><p>打开里面的<code>activity_main</code>并切换到视图,就可以看到显示的hello world在哪定义的啦</p></li></ul><h2 id="详解项目中的资源">详解项目中的资源</h2><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202303121403806.png" alt="image-20230312140317696" style="zoom:50%;"/><p><code>res</code> :</p><pre><code class="hljs">- `drawable`开头的文件夹是用来放**图片**的- `mipmap`开头的文件夹是用来放**应用图标**的- `values`下是用来放**字符串**的</code></pre><h1>第二章</h1><blockquote><p>活动:是一种可以包含用户界面的组件,主要用于和用户进行交互</p></blockquote><h2 id="活动的基本用法">活动的基本用法</h2><h3 id="创建活动">创建活动</h3><ol><li><code>app/src/main/java/com.example.activitytest</code>下面创建一个activity(empty activity),命名为FirstActivity</li></ol><h3 id="创建和加载布局">创建和加载布局</h3><p><font color = red >Android讲究逻辑和视图分离,每一个活动对应一个布局(用来显示界面内容)</font></p><p><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202303121452819.png" alt="image-20230312145236713"></p><p>eg:在布局中添加一个按钮button</p><p>创建布局:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;Button<br>    android:id=<span class="hljs-string">&quot;@+id/button_1&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>    android:text=<span class="hljs-string">&quot;Button 1&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>上述代码添加了一个Button元素,并且在Button内部增加了几个属性</p><ul><li><p><code>android:id</code>是给当前的元素定义一个唯一标识符</p><p><em>如果要在xml中引用一个id,则写成’@id/id_name’</em></p><p><em>如果是要在xml中定义一个id,则写成’+id/id_name’</em></p></li></ul><p>加载布局:<br>在<code>onCreat()</code>方法中加入:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">setContentView(R.layout.first_layout);<br></code></pre></td></tr></table></figure><h3 id="在AndroidManifest文件中注册">在AndroidManifest文件中注册</h3><p><font color = red >所有的活动都需要在AndroidManifest中注册才能生效</font></p><p>Android studio 比较人性化,会帮我们注册</p><p>光注册活动不行,还需要为程序配置主活动</p><h3 id="在活动中使用toast">在活动中使用toast</h3><p>这就是toast</p><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202303121527939.png" alt="image-20230312152702836" style="zoom:50%;" /><p>定义一个弹出toast的触发点.在<code>onCreate()</code>中添加以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Button</span> <span class="hljs-variable">button1</span> <span class="hljs-operator">=</span> (Button) findViewById(R.id.button_1);<br>button1.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span>&#123;<br>        Toast.makeText(FirstActivity.<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;YOU clicked Button 1&quot;</span>, Toast.LENGTH_SHORT).show();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>findViewById()方法获取到在布局文件中定义的元素,此方法返回一个View对象</li><li>调用setOnClickListener()方法为按钮注册一个监听器,点击按钮时就会执行监听器中的<code>onClick()</code>方法</li><li><code>makeText()</code>创建Toast对象,<code>show()</code>将Toast显示出来</li></ul><h3 id="活动中使用menu">活动中使用menu</h3><ol><li><p><code>res</code>下新建<code>menu</code>文件夹,再在<code>menu</code>下面新建一个菜单文件(Menu resource file),命名为<code>main</code></p></li><li><p>在<code>main.xml</code>中添加一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;menu xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;<br>    &lt;item<br>        android:id=<span class="hljs-string">&quot;@+id/add_item&quot;</span><br>        android:title=<span class="hljs-string">&quot;Add&quot;</span>/&gt;<br>    &lt;item<br>        android:id=<span class="hljs-string">&quot;@+id/remove_item&quot;</span><br>        android:title=<span class="hljs-string">&quot;Remove&quot;</span>/&gt;<br><br>&lt;/menu&gt;<br></code></pre></td></tr></table></figure><p><code>item</code>标签用来创建具体的某一个菜单项,通过<code>android:id</code>给这个菜单项指定一个唯一的标识符;通过<code>android:title</code>给这个菜单项指定一个名称</p></li><li><p>回到<code>FirstActivity</code>,重写<code>onCreatOptionMenu()</code>方法(快捷键<code>Ctrl+O</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onCreateOptionsMenu</span><span class="hljs-params">(Menu menu)</span> &#123;<br>       getMenuInflater().inflate(R.menu.main, menu);<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>通过<code>getMenuInflater()</code>可以得到<code>MenuInflater</code>对象,再调用它的<code>inflate()</code>方法,就可以给当前活动创建菜单了.</p><p>第二个参数用于指定我们的菜单项将添加到哪一个menu对象中</p></li><li><p>以上只是让菜单显示出来,接下来要定义菜单响应事件:在<code>FirstActivity</code>中重写<code>onOptionsItemSelected()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onOptionsItemSelected</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MenuItem item)</span> &#123;<br>        <span class="hljs-keyword">switch</span>(item.getItemId())&#123;<br>            <span class="hljs-keyword">case</span> R.id.add_item:<br>                Toast.makeText(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;You clicked Add&quot;</span>, Toast.LENGTH_SHORT).show();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> R.id.remove_item:<br>                Toast.makeText(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;You clicked remove&quot;</span>, Toast.LENGTH_SHORT).show();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>在<code>onOptionsItemSelected</code>中,通过调用<code>item.getItemId()</code>来判断我们点击的是哪一个菜单项</p></li><li><p>之后在每个菜单项里面加入自己的处理逻辑</p></li><li><p>重新运行程序</p></li></ol><h3 id="销毁一个活动">销毁一个活动</h3><p>Activity类提供了一个finish()方法，只需修改按钮监听器中的代码即可实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">button1.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span>&#123;<br>        finish();<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="使用Intent在活动之间穿梭">使用Intent在活动之间穿梭</h2><p><font color= red>Intent是Android程序中各组件之间进行交互的一种重要方式</font>，它不仅可以指明当前组间想要执行的动作，还可以在不同组间之间传递数据。</p><p>Intent一般可以用来启动活动、启动服务以及发送广播等场景。</p><p>Intent大致分为显示Intent和隐式Intent两种</p><h3 id="使用显式Intent">使用显式Intent</h3><p>Intent有多个构造函数的重载，其中一个是<code>Intent(Context packageContext,Class&lt;?&gt;cls)</code>,这个构造函数接受两个参数</p><ul><li>第一个参数<code>Context</code>要求提供一个启动活动的上下文</li><li>第二个参数<code>Class</code>则是指定想要启动的目标活动，通过这个构造函数就可以构建出Intent的“意图”。</li></ul><p>如何使用这个Intent?</p><blockquote><p>Activity类中提供了一个<code>startActivity()</code>方法，这个方法是专门用于启动活动的，它接受了一个Intent参数，这里我们将构建好的Intent传入<code>startActivity()</code>方法就可以启动目标活动了</p></blockquote><p>接下来修改<code>FirstActivity</code>中的按钮点击事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">button1.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span>&#123;<br>    <span class="hljs-comment">//                Toast.makeText(FirstActivity.this,&quot;YOU clicked Button 1&quot;, Toast.LENGTH_SHORT).show();</span><br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(FirstActivity.<span class="hljs-built_in">this</span>,SecondActivity.class);<br>        startActivity(intent);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>首先构建出一个Intent,传入<code>FirstActivity.this</code>作为上下文,传入<code>SecondActivity.class)</code>作为目标活动</p><p><em>所以,我们的&quot;意图&quot;是:在``FirstActivity<code>这个活动的基础上,打开</code>SecondActivity<code>这个活动,然后通过</code>startActivity()`方法来执行这个Intent</em></p><h3 id="使用隐式Intent">使用隐式Intent</h3><p>隐式Intent*不明确指出我们想要启动哪一个活动，*而是指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent,帮助我们找出合适的活动去启动</p><ul><li>在<code>AndroidMainifest.xml</code>中添加<code>&lt;intent-filter&gt;</code>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"> &lt;activity<br>    android:name=<span class="hljs-string">&quot;.SecondActivity&quot;</span><br>    android:exported=<span class="hljs-string">&quot;false&quot;</span>&gt;<br>    &lt;intent-filter&gt;<br>        &lt;action android:name=<span class="hljs-string">&quot;com.example.activitest.ACTION_START&quot;</span> /&gt;<br>        &lt;category android:name=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;<br>    &lt;/intent-filter&gt;<br><br>    &lt;meta-data<br>        android:name=<span class="hljs-string">&quot;android.app.lib_name&quot;</span><br>        android:value=<span class="hljs-string">&quot;&quot;</span> /&gt;<br>&lt;/activity&gt;<br></code></pre></td></tr></table></figure><p>在<code>action</code>标签中我们指明了当前活动可以响应<code>com.example.activity.ACTION_START</code>这个action,而category标签则包含了一些附加信息，更加精确地指明了当前的活动能够响应Intent中还可能带有的category。</p><p><strong>只有<code>&lt;action&gt;</code>和<code>&lt;category&gt;</code>中的内容同时能够匹配上Intent中指定的action和category时，这个活动才能响应该Intent。</strong></p><ul><li><p>修改<code>FirstActivity</code>中的点击事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span>&#123;<br><span class="hljs-comment">//                Toast.makeText(FirstActivity.this,&quot;YOU clicked Button 1&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="hljs-comment">//                Intent intent = new Intent(FirstActivity.this,SecondActivity.class);</span><br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-string">&quot;com.example.activitest.ACTION_START&quot;</span>);<br>                startActivity(intent);<br>            &#125;<br></code></pre></td></tr></table></figure></li><li><p>重新运行程序</p></li></ul><h3 id="更多隐式Intent的用法">更多隐式Intent的用法</h3><p>*使用隐式Intent，不仅可以启动自己程序内的Activity，还可以启动其他程序的Activity，*这就使多个应用程序之间的功能共享成为了可能。</p><p>比如你的应用程序中需要展示一个网页，这时你没有必要自己去实现一个浏览器，只需要调用系统的浏览器来打开这个网页就行了。<br>修改FirstActivity中按钮点击事件的代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span>&#123;<br><span class="hljs-comment">//                Toast.makeText(FirstActivity.this,&quot;YOU clicked Button 1&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="hljs-comment">//                Intent intent = new Intent(FirstActivity.this,SecondActivity.class);</span><br><span class="hljs-comment">//                Intent intent = new Intent(&quot;com.example.activitest.ACTION_START&quot;);</span><br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_VIEW);<br>                intent.setData(Uri.parse(<span class="hljs-string">&quot;https://zrpiupiupiu.github.io/&quot;</span>));<br>                startActivity(intent);<br>            &#125;<br></code></pre></td></tr></table></figure><p>这里我们首先指定了Intent的action是<code>Intent.ACTION_VIEW</code>，这是一个Android系统内置的动作，其常量值为<code>android.intent.action.VIEW</code>然后通过<code>Uri.parse()</code>方法将一个网址字符串解析成一个Uri对象，再调用Intent的<code>setData()</code>方法将这个Uri对象传递进去。重新运行程序，在<code>FirstActivity</code>界面点击按钮就可以看到打开了系统浏览器。</p><h3 id="其他协议的响应">其他协议的响应</h3><p>除了https协议外，我们还可以指定很多其他协议，比如geo表示显示地理位置、tel表示拨打电话。下面的代码展示了如何在我们的程序中调用系统拨号界面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">button1.setOnClickListener &#123;<br>   <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_DIAL);<br>   intent.setData(Uri.parse(<span class="hljs-string">&quot;tel:10086&quot;</span>));<br>   startActivity(intent)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>首先指定了Intent的action是<code>Intent.ACTION_DIAL</code>，这又是一个Android系统的内置动作。然后在data部分指定了协议是tel，号码是10086。</p><h3 id="向下一个活动传递数据">向下一个活动传递数据</h3><p>Intent中提供了一系列<code>putExtra()</code>方法的重载，可以把我们想要传递的数据暂存在Intent中，在启动另一个Activity后，只需要把这些数据从Intent中取出就可以了</p><p>现在,我们在<code>FirstActivity</code>中有一个字符串,想把这个字符串传递给<code>SecondActivity</code></p><ul><li>首先在<code>FierstActivity</code>中改写点击按钮事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"> button1.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span>&#123;<br><span class="hljs-comment">//                Toast.makeText(FirstActivity.this,&quot;YOU clicked Button 1&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="hljs-comment">//                Intent intent = new Intent(FirstActivity.this,SecondActivity.class);</span><br><span class="hljs-comment">//                Intent intent = new Intent(&quot;com.example.activitest.ACTION_START&quot;);</span><br><br><span class="hljs-comment">//                Intent intent = new Intent(Intent.ACTION_VIEW);</span><br><span class="hljs-comment">//                intent.setData(Uri.parse(&quot;https://zrpiupiupiu.github.io/&quot;));</span><br><br><span class="hljs-comment">//                Intent intent = new Intent(Intent.ACTION_DIAL);</span><br><span class="hljs-comment">//                intent.setData(Uri.parse(&quot;tel:10086&quot;));</span><br><br>                <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello SecondActivity&quot;</span>;<br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(FirstActivity.<span class="hljs-built_in">this</span>,SecondActivity.class);<br>                intent.putExtra(<span class="hljs-string">&quot;extra_data&quot;</span>,data);<br>                startActivity(intent);<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><p>这里还是使用显式Intent的方式来启动<code>SecondActivity</code>，并通过<code>putExtra()</code>方法传递了一个字符串。注意，这里<code>putExtra()</code>方法接收两个参数，第一个参数是键，用于之后从Intent中取值，第二个参数才是真正要传递的数据。</p><ul><li>然后在<code>SecondActivity</code>中将传递的数据取出，并打印出来，代码如下所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.second_layout);<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> getIntent();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> ((Intent) intent).getStringExtra(<span class="hljs-string">&quot;extra_data&quot;</span>);<br>        Log.d(<span class="hljs-string">&quot;SecondActivity&quot;</span>,data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>getIntent()</code>方法获取到用于启动<code>SecondActivity</code>的Intent</p><p>调用<code>getStringExtra()</code>方法获取传递的数据(字符串)</p><ul><li>运行程序</li></ul><h3 id="返回数据给上一个活动">返回数据给上一个活动</h3><h2 id="活动的生命周期">活动的生命周期</h2><h3 id="返回栈">返回栈</h3><ul><li><p>Android使用任务(Task)来管理活动</p></li><li><p>一组任务就是一组存放在栈里的活动的集合</p></li><li><p>系统总是会把栈顶的活动显示给用户</p></li></ul><h3 id="活动状态">活动状态</h3><blockquote><p>每个活动在其生命周期中最多可能有4种状态</p></blockquote><ol><li><p><strong>运行状态</strong></p><p>活动处于返回栈的栈顶时</p></li><li><p><strong>暂停状态</strong></p><p>活动不再处于栈顶,但仍然是可见时</p></li><li><p><strong>停止状态</strong></p><p>活动不再处于栈顶,并且完全不可见</p></li><li><p><strong>销毁状态</strong></p><p>活动从返回栈中移除后</p></li></ol><h3 id="活动的生存期">活动的生存期</h3><p>Activity类中定义了7个回调方法</p><ol><li><p><code>onCreate()</code></p><p>在活动第一次被创建时调用</p><p>我们在这个方法中完成活动的初始化操作,例如加载布局,绑定事件等</p></li><li><p><code>onStart()</code></p><p>在活动由不可见变为可见时调用</p></li><li><p><code>onResume()</code></p><p>在活动准备好和用户进行交互的时候调用</p><p>此时的活动一定处于返回栈的栈顶,并且处于运行状态</p></li><li><p><code>onPause()</code></p><p>在系统准备去启动或恢复另一个活动的时候调用</p><p>通常会在这个方法中将一些消耗cpu的资源释放掉,以及保存一些关键的数据,但这个方法一定要快,不然会影响到新的栈顶活动的使用</p></li><li><p><code>onStop()</code></p><p>在活动完全不可见的时候调用</p>  <p class="note note-warning">它和onPause()方法的主要区别在于,如果启动的新活动是一个对话框式的活动,那么onPause()方法会得到执行,而onStop()方法并不会执行</p></li><li><p><code>onDestory()</code></p><p>在活动被销毁之前调用,之后的活动状态变为销毁状态</p></li><li><p><code>onRestart()</code></p><p>在活动由静止状态转变为运行状态之前调用.即活动被重新启动了</p></li></ol><p><strong>以上7种方法中除了<code>onReatart()</code>方法,其他都是两两对应的,所以又可以将活动分为3种生存期</strong></p><ul><li>完整生存期:从<code>onCreate()</code>到<code>onDestroy()</code>方法之间，活动会在<code>onCreate()</code>完成初始化操作，在<code>onDestroy()</code>中释放占用的资源。</li><li>可见生存期:从<code>onStart()</code>到<code>onStop()</code>方法之间。在这段时间，活动对于用户是可见的，但是并非是在最前端可以与用户进行交互的。</li><li>前台生存期:从 <code>onResume()</code>到<code>onPause</code>方法之间,在这个期间，此活动在所有活动之前并与用户进行交互。我们平时看到和接触最多的也就是这个状态下的活动</li></ul><p>下面这个是Android官方提供的活动生命周期的示意图:</p><p><img src="/img/activity.png"></img></p><h3 id="活动的启动模式">活动的启动模式</h3><ol><li><p>standard</p><p>活动的默认启动模式,每次都新建一个实例对象</p></li><li><p>singleTop</p><p>如果在任务栈顶发现了相同的实例则重用，否则新建并压入栈顶</p></li><li><p>singleTask</p><p>每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例,如果发现已经存在则直接使用该实例,并把在这个活动之上的所有活动统统出栈,如果没有发现就会创建一个新的活动实例</p></li><li><p>singleInstance</p><p>会启用一个新的返回栈来管理这个活动</p></li></ol><p>standard:</p><p><img src="/img/android-lanchmode-standard.gif"></img></p><p>singleTop:</p><p>启动活动时如果发现返回栈的栈顶已经是该活动,则认为可以直接使用它,不会再创建新的活动实例,如果未处于栈顶,则会创建新的实例</p><p><img src="/img/android-lanchmode-singletop.gif"></img></p><p>配制方法实在<code>AndroidMainifest.xm</code>l中进行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.SingleTopActivity&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/singletop&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:launchMode</span>=<span class="hljs-string">&quot;singleTop&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><p>singleTask:</p><p>与singleTop的区别是singleTask会扫描整个任务栈并制定策略</p><p><img src="/img/android-lanchmode-singletask.gif"></img></p><p>使用时需要小心因为会将之前入栈的实例之上的实例全部移除，需要格外小心逻辑。</p><p>配制方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.SingleTopActivity&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/singletop&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:launchMode</span>=<span class="hljs-string">&quot;singleTop&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><h1>第三章</h1><h2 id="常用控件的使用">常用控件的使用</h2><p>基本用法:</p><ul><li>给控件定义一个id</li><li>指定控件的宽度和高度</li><li>适当加入控件的特有属性</li><li>…</li></ul><h3 id="textView">textView</h3><ol><li><code>android:gravity</code>指定文字对齐方式,其值有top,bottom,left,right,center等</li><li><code>android:textSize</code>指定文字大小,使用sp作为单位</li><li><code>android:txetColor</code>指定文字颜色</li></ol><h3 id="Button">Button</h3><blockquote><p>系统会对Button中的所有英文字母自动进行大写转换</p><p>如果不想要这种效果,可以使用 <code>android:textAllcaps=&quot;false&quot;</code>来禁用这一默认特性</p></blockquote><h3 id="EditText">EditText</h3><blockquote><p>EditText允许用户在控件中输入和编辑内容,并可以在程序中对这些内容进行处理</p></blockquote><ol><li><code>android:hint</code>指定提示性文本在输入框中,一旦有内容输入,提示性文本就消失</li><li><code>android:maxLines</code>指定EditText的最大行数,当输入内容超过指定行数时,文本就会向上滚动,而EditText则不会再继续拉伸</li></ol><h3 id="ImageView">ImageView</h3><p>这个控件用于在界面上展示图片</p><h3 id="ProgressBar">ProgressBar</h3><p>用于在界面上显示一个进度条,表示我们的程序正在加载一些数据</p><h3 id="AlertDialog">AlertDialog</h3><p>可以在当前界面弹出一个对话框,这个对话框置顶于所有界面元素之上,能够屏蔽掉其他控件的交互能力</p><p>所以AlertDialog一般都是用于提示一些非常重要的内容或者警告信息</p><h3 id="ProgressDialog">ProgressDialog</h3><p>与AlertDialog相似,可以在当前界面弹出一个对话框,这个对话框置顶于所有界面元素之上,能够屏蔽掉其他控件的交互能力.不同的是,ProgressDialog会在对话框中显示一个进度条,一般比较当前操作比较耗时,让用户耐心等待</p><h2 id="详解四种基本布局">详解四种基本布局</h2><p><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202211062257234.png" alt="屏幕截图 2022-11-06 220955"></p><h3 id="线性布局LinearLayout">线性布局LinearLayout</h3><p>这个布局会将它所包含的控件在线性方向上依次排列</p><h3 id="相对布局RelativeLayout">相对布局RelativeLayout</h3><p>通过相对定位的方式让控件出现在布局的任何位置</p><p>RelativeLayout中的属性非常多,但大多有规律可循</p><h3 id="帧布局FrameLayout">帧布局FrameLayout</h3><p>比前两种布局简单,应用场景也少许多</p><p>所有的控件都会默认摆放在布局的左上角</p><h3 id="百分比布局">百分比布局</h3><p>直接指定控件在布局中所占的百分比</p><h2 id="创建自定义控件">创建自定义控件</h2><p><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202211101727708.png" alt="image-20221110172738596"></p><p>所有的控件都是直接或间接继承自View,所有布局都是直接或间接继承自ViewGroup</p><p>View是Android中最基本的一种ui组件,它可以在屏幕上绘制一块矩形区域,并且能够响应这块区域的各种事件</p><h3 id="引入布局">引入布局</h3><ol><li><p>新建一个布局<code>title.xml</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;LinearLayout xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;<br><br>    &lt;Button<br>        android:id=<span class="hljs-string">&quot;@+id/title_back&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span><br>        android:layout_margin=<span class="hljs-string">&quot;5dp&quot;</span><br>        android:text=<span class="hljs-string">&quot;Back&quot;</span><br>        android:textColor=<span class="hljs-string">&quot;#fff&quot;</span> /&gt;<br>    &lt;TextView<br>        android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:id=<span class="hljs-string">&quot;@+id/title_edit&quot;</span><br>        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span><br>        android:layout_margin=<span class="hljs-string">&quot;5dp&quot;</span><br>        android:text=<span class="hljs-string">&quot;Edit&quot;</span><br>        android:textColor=<span class="hljs-string">&quot;#fff&quot;</span> /&gt;<br><br>    &lt;Button<br>        android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:id=<span class="hljs-string">&quot;@+id/title_edit&quot;</span><br>        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span><br>        android:layout_margin=<span class="hljs-string">&quot;5dp&quot;</span><br>        android:textColor=<span class="hljs-string">&quot;#fff&quot;</span><br>        android:text=<span class="hljs-string">&quot;Edit&quot;</span> /&gt;<br><br>&lt;/LinearLayout&gt;<br></code></pre></td></tr></table></figure></li></ol><h3 id="创建自定义控件-2">创建自定义控件</h3><h2 id="LIstView控件">LIstView控件</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda入手</title>
    <link href="/2022/10/20/Anaconda%E5%85%A5%E6%89%8B/"/>
    <url>/2022/10/20/Anaconda%E5%85%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p class = "note note-success">Anaconda是一个提供python开发所需的工具包</p><blockquote><p>环境 = “好比一栋楼，在楼里面分配一间屋给各种‘包’放，每间房里面的‘包’互不影响”</p><p>激活环境 = “告诉电脑，我现在要用这个屋子里面的‘包’来做东西了所以要进这间屋子”</p><p>移除环境 = “现在这个屋子里面我原来要用的东西现在不需要了把它赶出去节省电脑空间”</p><p>Conda创建环境相当于创建一个虚拟的空间将这些包都装在这个位置，我不需要了可以直接打包放入垃圾箱，同时也可以针对不同程序的运行环境选择不同的conda虚拟环境进行运行。</p><p><strong>例如：</strong></p><p>env1装了pytorch1.0，env2装了pytorch1.2，需要使用1.0的时候激活env1，需要使用pytorch版本1.2的时候激活env2，这样就不用每次配环境一个一个包重新安装。</p></blockquote><h1>安装与配置</h1><h2 id="安装">安装</h2><ul><li><p>我是直接在<a src="https://www.anaconda.com/products/distribution">官网</a>下载的</p><p><img src="/img/anaconda安装.png"></img></p></li><li><p>接下来就是安装了:</p><p><img src="/img/anaconda安装02.png"></img></p><p>之后跟着一步一步来,耐心等待安装完成</p></li></ul><h2 id="配置">配置</h2><p>在环境变量中添加以下:</p><p><img src="/img/anaconda环境配置.png"></img></p><p>在这些都完成之后,用命令行输入conda,如果是出现如下情况,就说明安装好啦</p><p><img src="/img/anaconda01.png"></img></p><h1>基本使用:</h1><ul><li><p>创建虚拟环境:<code>conda create -n 环境名</code></p><p><img src="/img/anaconda+pytorch虚拟环境安装.png"></img></p></li><li><p>查看当前conda所有环境:<code>conda info --envs</code></p></li><li><p>激活环境:<code>Conda activate 环境名</code></p></li><li><p>查看环境中的包:<code>conda list</code></p></li><li><p>退出当前环境: <code> conda deactivate 环境名</code></p></li><li><p>删除环境: <code>conda remove -n 环境名 --all</code></p></li></ul><p><img src="/img/anaconda02.png"></img></p><p><img src="/img/anaconda03.png"></img></p>]]></content>
    
    
    
    <tags>
      
      <tag>Anaconda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue报错分析及解决</title>
    <link href="/2022/10/13/vue%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    <url>/2022/10/13/vue%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h1>“xxx” was accessed during render but is not defined on instance.</h1><p>原因:<br>你的“”xxx‘’属性或者&quot;xxx&quot;方法没有定义</p><p>解决方案:</p><p>查看你的data或者methods或者prop</p><h1>直接引入element plus报一堆错</h1><p><img src = "/img/vue02.png"></img></p><p>原因:</p><p>element plus案例代码使用ts写的</p><p>解决方案:</p><p>在我们的vue文件中引入ts进行混用</p><ul><li><p>安装typescript及loader</p><p><code>npm install typescript ts-loader –save-dev</code></p></li><li><p>安装<code>vue-property-decorator</code></p><p><code>npm install --save vue-property-decorator</code></p></li><li><p>配置<code>vue.config.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">module.exports = &#123;<br>  configureWebpack: &#123;<br>    resolve: &#123;<br>      extensions: [“.ts”, “.tsx”, “.js”, “.json”]<br>    &#125;,<br>    module: &#123;<br>      rules: [<br>      &#123;<br>        test: /\.tsx?$/,<br>        loader: ‘ts-loader’,<br>        exclude: /node_modules/,<br>        options: &#123;<br>          appendTsSuffixTo: [/\.vue$/],<br>        &#125;<br>      &#125;<br>      ]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>新建一个<code>tsconfig.json</code>在<code>src</code>下面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;<br>    &quot;compilerOptions&quot;: &#123;<br>        &quot;target&quot;: &quot;es5&quot;, <br>        &quot;module&quot;: &quot;commonjs&quot;, <br>        &quot;strict&quot;: true, <br>        &quot;strictNullChecks&quot;: true, <br>        &quot;esModuleInterop&quot;: true, <br>        &quot;experimentalDecorators&quot;: true<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在<code>src</code>下继续新建一个ts文件,内容空白即可</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue Router 搭建</title>
    <link href="/2022/10/13/Vue-Router-%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/10/13/Vue-Router-%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="安装Vue-Router路由">安装Vue Router路由</h2><p>首先将 Vue Router 安装到刚刚创建的 Vue3 项目中。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">npm i vue-router@<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="创建页面组件">创建页面组件</h2><p>没有把页面直接放在组件<code>component</code> 里面</p><ul><li>在<code>src</code>下新建<code>views</code> 文件夹</li><li>在<code>views</code> 下面创建<code>HomeView.vue</code>和<code>AboutView.vue</code></li><li>在两个文件里面添加一些内容</li></ul><p><code>HomeView.vue</code> 中:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    这是点开的首页噢</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p><code>AboutView.vue</code> 中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    这是about页面喔</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h2 id="配置并建立vue-router路由">配置并建立vue router路由</h2><ul><li><p>首先要添加配置文件:在<code>src</code> 下新建<code>router</code> 文件夹</p></li><li><p>在<code>router</code> 下配置文件<code>index.js</code></p></li><li><pre><code class="language-vue">import &#123; createRouter, createWebHashHistory &#125; from 'vue-router'import HomeView from '../views/HomeView.vue'const routes = [  &#123;    path: '/',    name: 'home',    component: HomeView  &#125;,  &#123;    path: '/about',    name: 'about',    // route level code-splitting    // this generates a separate chunk (about.[hash].js) for this route    // which is lazy-loaded when the route is visited.    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ '../views/AboutView.vue')  &#125;, ]const router = createRouter(&#123;  history: createWebHashHistory(),  routes&#125;)export default router<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>  <br><br>  在这个配置文件中,我们使用一个数组来写router指向的每一个分页面<br><br>  + `path` 是路由分配的url<br>  + `name` 是路由指向这个页面的时候显示的名字<br>  + `component` 是路由调用这个页面时加载的组件名<br>  + 这段代码的最后是router的主体,我们创建了一个路由,使用`histor` 模式<br><br>  &lt;p <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;note note-info&quot;</span>&gt;`history` 模式是 `hash` 模式的升级版，主要区别在浏览器链接的显示的不同&lt;/p&gt;<br><br>  - hash 模式：把前端路由路径用 # 号拼接在真实 URL 后面的模式。当 # 后面的路径发生变化时，浏览器不会重新发起请求，而是出发 hashchange 事件。hash 模式链接样式：`http:<span class="hljs-comment">//localhost:8080/#/home`</span><br><br>  - history 模式：history API 是 HTML5 的新特性，允许开发者直接更改前端路由。history 模式链接样式：`http:<span class="hljs-comment">//localhost:8080/home`</span><br><br>    <br><br>## 在main.js中引入router<br><br>```javascript<br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><br>createApp(App).use(router).mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure></code></pre></li></ul><h2 id="在-App-vue-中使用-router-view-和-router-link">在 App.vue 中使用<code>&lt;router-view&gt;</code>和<code>&lt;router-link&gt;</code></h2><p>App.vue 是项目的主组件，可以理解为项目的入口页面，所有页面都在 App.vue 页之下进行切换。接下来我们要来修改 App.vue ，以适应我们添加的 Router 功能。</p><p>文件位置：/src/App.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span> 首页 <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> |</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span> 关于 <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>最后再<code>npm run serve</code>康康吧</p><p><img src="/img/vue router01.png"></img></p><br>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue入门</title>
    <link href="/2022/10/12/vue%E5%85%A5%E9%97%A8/"/>
    <url>/2022/10/12/vue%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[ <p class = "note note-success">记录一下自己vue的学习</p><h1>初识vue</h1><p>vue2与vue3的安装和卸载不一样</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-number">3</span>x<br><span class="hljs-built_in">npm</span> install -g @vue/cli<br><span class="hljs-built_in">npm</span> uninstall -g @vue/cli<br><br><span class="hljs-number">2</span>x<br><br><span class="hljs-built_in">npm</span> install -g vue-cli<br><span class="hljs-built_in">npm</span> uninstall -g vue-cli<br></code></pre></td></tr></table></figure><h2 id="初始化新项目">初始化新项目</h2><ol><li>可以直接使用<code>vue ui</code> 以图形化界面来创建的</li><li>使用<code>vue create project</code>创建</li></ol><h2 id="项目结构">项目结构</h2><ul><li><code>public</code>: 这个目录包含一些在 <a href="https://webpack.js.org/">Webpack</a> 编译过程中没有加工处理过的文件（有一个例外：index.html 会有一些处理）。<ul><li><code>favicon.ico</code>: 这个是项目的图标，当前就是一个 Vue 的 logo。</li><li><code>index.html</code>: 这是应用的模板文件，Vue 应用会通过这个 HTML 页面来运行，也可以通过 lodash 这种模板语法在这个文件里插值。</li></ul></li></ul> <p class = "note note-info">备注： 这个不是负责管理页面最终展示的模板，而是管理 Vue 应用之外的静态 HTML 文件，一般只有在用到一些高级功能的时候才会修改这个文件。</p><ul><li><code>src</code>：这个是 Vue 应用的核心代码目录<ul><li><code>main.js</code>：这是应用的入口文件。目前它会初始化 Vue 应用并且制定将应用挂载到 <code>index.html</code> 文件中的哪个 HTML 元素上。通常还会做一些注册全局组件或者添额外的 Vue 库的操作。</li><li><code>App.vue</code>：这是 Vue 应用的根节点组件，往下看可以了解更多关注 Vue 组件的信息。</li><li><code>components</code>：这是用来存放自定义组件的目录，目前里面会有一个示例组件。</li><li><code>assets</code>：这个目录用来存放像 CSS、图片这种静态资源，但是因为它们属于代码目录下，所以可以用 webpack 来操作和处理。意思就是你可以使用一些预处理比如 <a href="https://sass-lang.com/">Sass/SCSS</a> 或者 <a href="https://stylus-lang.com/">Stylus</a>。</li></ul></li></ul> <p class = "note note-info">备注： 根据创建项目时候的一些配置项，可能会有一些其他的预设目录（例如，如果你选择了路由配置，会看到一个 views 的文件夹）</p><h2 id="vue-文件（单文件组件）">.vue 文件（单文件组件）</h2><p>组件是构建 Vue 应用中非常重要的一部分</p><p>组件可以把一个很大的应用程序拆分为独立创建和管理的不相关区块，然后彼此按需传递数据，这些小的代码块可以方便更容易的理解和测试。</p><p><strong>vue使用单文件组件， 把模板、相关脚本和 CSS 一起整合放在 .vue 结尾的一个单文件中</strong>。这些文件最终会通过 JS 打包工具（例如 Webpack）处理，这意味着你可以使用构建时工具。你可以使用比如 Babel、TypeScript、SCSS 等来创建更多复杂的组件。</p><p>另外，使用 Vue CLI 创建的项目被配置为在开箱即用的情况下借助 Webpack 使用 <code>.vue</code>文件。实际上，如果您查看我们使用 CLI 创建的项目中的<code>src</code>文件夹，您会看到第一个<code>.vue </code>文件：<code>App.vue</code></p><h3 id="APP-vue">APP.vue</h3><p>打开 <code>App.vue</code> 文件，可以看到由 <code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 三部分组成，分别包含了<em>组件的模板</em>、<em>脚本</em> 和<em>样式</em> 相关的内容。所有的单文件组件都是这种类似的基本结构。</p><ul><li><code>&lt;template&gt;</code> 包含了所有的标记结构和组件的展示逻辑。template 可以包含任何合法的 HTML，以及一些我们接下来要讲的 Vue 特定的语法。</li></ul> <p class = "note note-info">备注： 通过设置template 标签的 lang 属性，例如可以通lang="pug" 就可以在使用 Pug 模板来替代标准 HTML。在本教程中我们依然会使用标准 HTML，但是你还是值得知道这种可行的方式。</p><ul><li><code>&lt;script&gt;</code> 包含组件中所有的非显示逻辑，最重要的是， <code>&lt;script&gt;</code> 标签需要默认导出一个 JS 对象。该对象是您在本地注册组件、定义属性、处理本地状态、定义方法等的地方。在构建阶段这个包含 template 模板的对象会被处理和转换成为一个有 render() 函数的 Vue 组件。</li><li>组件的 CSS 应该写在 <code>&lt;style&gt;</code> 标签里，如果你添加了 <code>scoped</code> 属性（形如 <code>&lt;style scoped&gt;</code>），Vue 会把样式的范围限制到单文件组件的内容里。这个是类似于 CSS-in-JS 的解决方案，只不过允许书写纯粹的 CSS。</li></ul> <p class = "note note-info">备注： 如果通过 CLI 创建项目时选择了 CSS 预处理器，则可以将 lang 属性添加到 style 标签中，以便 Webpack 可以在构建时处理内容。例如，< style lang ="scss"> 将允许您在样式信息中使用 SCSS 语法。</p><p>对于 <code>App.vue</code>，我们的默认导出将组件的名称设置为 <code>app</code> ，并通过将 <code>HelloWorld</code> 组件添加到 <code>components</code> 属性中来注册它。以这种方式注册组件时，就是在本地注册。本地注册的组件只能在注册它们的组件内部使用，因此您需要将其导入并注册到使用它们的每个组件文件中。这对于拆包 / tree shaking（译者注：一种减小包体积优化方式）很有用，因为并不是应用程序中的每个页面都不一定需要每个组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">HelloWorld</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/HelloWorld.vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;app&#x27;</span>,<br>  <span class="hljs-attr">components</span>: &#123;<br>    <span class="hljs-comment">// 可以在这里本地注册组件。</span><br>    <span class="hljs-title class_">HelloWorld</span><br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure> <p class = "note note-info">备注： 如果想要使用 TypeScript 语法，应该将 < script > 标签的 lang 属性设置为 < script lang="ts" > 来告诉编译器你要使用 TypeScript。</p><h2 id="本地运行程序">本地运行程序</h2><p>终端中输入<code>npm run serve</code>,得到如下结果:</p><p><img src = "/img/vue01.png"></img></p><h2 id="vue3-中使用axios">vue3 中使用axios</h2><ol><li>安装axios</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm install axios<br></code></pre></td></tr></table></figure><h2 id="安装elementplus">安装elementplus</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm install element-plus --save<br></code></pre></td></tr></table></figure><p><code>main.js</code>中加入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 新增代码：引入全部组件及样式</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementPlus</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-plus/dist/index.css&#x27;</span>;<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementPlus</span>)<br><br></code></pre></td></tr></table></figure><h2 id="卸载elsint">卸载elsint</h2><p>1:在控制台输入</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm uninstall eslint <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>2：卸载完成，打开package.json文件，找到eslint版本位置 删除即可 删除此段代码：<code>&quot;@vue/cli-plugin-eslint&quot;: &quot;~5.0.0&quot;,</code></p><p><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202304091616773.png" alt="image-20230409161632644"></p><h2 id="vue中使用threejs">vue中使用threejs</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save three</span><br></code></pre></td></tr></table></figure><h1>vue 访问本地文件 相对路径 文件目录 three.js 加载模型</h1><p><strong>需要注意的一点就是，路径已/开头，是从public文件开始，public下文件url直接就是static/building/human-female-breast-anatomy.quads.glb“</strong></p><h2 id="安装echarts">安装echarts</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">npm install echarts --save<br></code></pre></td></tr></table></figure><p><code>main.js</code>中添加<code>import * as echarts from 'echarts'</code></p><h1>echarts 调整canvas内部里面图表与外框大小比例的方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">grid</span>:&#123;<br>      <span class="hljs-attr">x</span>:<span class="hljs-number">25</span>,<br>      <span class="hljs-attr">y</span>:<span class="hljs-number">45</span>,<br>      <span class="hljs-attr">x2</span>:<span class="hljs-number">5</span>,<br>      <span class="hljs-attr">y2</span>:<span class="hljs-number">20</span>,<br>      <span class="hljs-attr">borderWidth</span>:<span class="hljs-number">1</span><br>    &#125;,<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zrpiupiupiu/learngit/main/202304152339474.png" alt="img"></p><h3 id="安装词云图">安装词云图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">npm install echarts-wordcloud<br></code></pre></td></tr></table></figure><p><code>main.js</code>中添加<code>import 'echarts-wordcloud</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Daovoice实现在线聊天</title>
    <link href="/2022/10/11/%E7%94%A8Daovoice%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9/"/>
    <url>/2022/10/11/%E7%94%A8Daovoice%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[  <p class="note note-info">记录一下用daovoice实现博客的在线聊天功能</p><h2 id="dog-首先-注册Daovoice账号"><a href="#dog-首先-注册Daovoice账号" class="headerlink" title=":dog:首先 注册Daovoice账号"></a>:dog:首先 注册Daovoice账号</h2><ul><li><a src="http://dashboard.daovoice.io/get-started?invite_code=7f3d6e70">点击这儿进行注册</a></li></ul><p>注册成功之后点击左边的<code>应用设置</code>-&gt;<code>安装到网站</code>-&gt;<code>仅匿名用户</code></p><p><img src="/img/daovoice.png"></img></p><ul><li>我们可以看到,具体该怎么做他已经写的很详细了捏</li></ul><h2 id="cow-copy"><a href="#cow-copy" class="headerlink" title=":cow:copy"></a>:cow:copy</h2><p>我们把上图中看到的代码copy到<code>themes\fluid\layout\_partials/head.ejs</code> 下面 (现在用的是fludi,就以fluid为例)</p><p>成果如下图:</p><p><img src="/img/daovoice02.png"></img></p><h2 id="snowman-调整"><a href="#snowman-调整" class="headerlink" title=":snowman:调整"></a>:snowman:调整</h2><p>daovoice还可以自行设置欢迎词与定制聊天窗口样式(虽说很单一……)</p><p>位置就在 <code>应用设置</code>-&gt;<code>聊天设置</code> 里,</p><p><img src="/img/daovoice03.png"></img></p><h2 id="cloud-final"><a href="#cloud-final" class="headerlink" title=":cloud:final"></a>:cloud:final</h2><p>最后当然就是我们的<code>hexo g</code>与<code>hexo d</code>啦</p><p>最终效果如下:</p><p><img src="/img/daovoice04.png"></img></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何用hexo写博客</title>
    <link href="/2022/10/10/%E9%87%8D%E8%A3%85%E5%95%A6/"/>
    <url>/2022/10/10/%E9%87%8D%E8%A3%85%E5%95%A6/</url>
    
    <content type="html"><![CDATA[<blockquote></blockquote><h2 id="panda-face-创建一个新文章"><a href="#panda-face-创建一个新文章" class="headerlink" title=":panda_face:创建一个新文章"></a>:panda_face:创建一个新文章</h2><ul><li><p><code>hexo new &quot;title&quot;</code></p><p>生成的新文章就在\source_posts里面啦</p></li><li><p>直接在\source_posts里面创建.md文件即可</p></li></ul><p>写完小文章之后运行 <code>hexo g</code> 以及 <code>hexo d</code> 就可以发布啦</p><h2 id="chicken-插入图片"><a href="#chicken-插入图片" class="headerlink" title=":chicken:插入图片"></a>:chicken:插入图片</h2><ul><li><p>(不使用图床)在source下创建img文件夹专门存放图片,文章中的图片直接用img标签引入,src里填写相对路径</p></li><li><p>(使用图床)picgo</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何用hexo写博客</title>
    <link href="/2022/10/10/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/10/10/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote></blockquote><h2 id="🐼-创建一个新文章">🐼 创建一个新文章</h2><ul><li><p><code>hexo new &quot;title&quot;</code></p><p>生成的新文章就在\source_posts里面啦</p></li><li><p>直接在\source_posts里面创建.md文件即可</p></li></ul><p>写完小文章之后运行 <code>hexo g</code> 以及 <code>hexo d</code> 就可以发布啦</p><h2 id="🐔-插入图片">🐔 插入图片</h2><ul><li><p>(不使用图床)在source下创建img文件夹专门存放图片,文章中的图片直接用img标签引入,src里填写相对路径</p></li><li><p>(使用图床)picgo</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/10/hello-world/"/>
    <url>/2022/10/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
